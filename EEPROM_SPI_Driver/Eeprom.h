#pragma once
#include "SpiDevice.h"
#include <cstdint>
#include <chrono>

/**
 * @brief Драйвер микросхемы EEPROM памяти (25LC040A)
 * 
 * Поддерживает операции для работы с микросхемой:
 * - Чтение/запись отдельных битов
 * - Чтение/запись отдельных байтов
 * - Чтение/запись буфера произвольной длины (с автоматическим страничным разбиением)
 * 
 * @note Микросхема 25LC040A имеет следующие характеристики:
 *       - Объём: 4 Кбит = 512 байт
 *       - Адресация: 9 бит (адреса 0x000–0x1FF)
 *       - Размер страницы: 16 байт
 *       - Время записи страницы: до 5 мс
 *       - Интерфейс: SPI
 */

class Eeprom : public SpiDevice {
public:
    /// @brief Общий объём памяти микросхемы в байтах (512 байт (4 Кбит))
    static constexpr uint16_t MEMORY_SIZE = 512;

    /// @brief Размер страницы для операций записи (16 байт для 25LC040A)
    /// @note Запись, пересекающая границу страницы автоматически
    ///       разбивается на несколько операций.
    static constexpr uint16_t PAGE_SIZE = 16;

    /**
     * @brief Конструктор драйвера EEPROM
     * 
     * @param driver Ссылка на реализацию драйвера SPI.
     */
    explicit Eeprom(SpiDriver& driver);

    /**
     * @brief Записывает один байт данных по указанному адресу
     * 
     * @param address Адрес в памяти (допустимый диапазон: 0–511)
     * @param value Значение байта для записи (0x00–0xFF)
     * @return true если запись успешна, false при ошибке
     */
    bool writeByte(uint16_t address, uint8_t value);
    /**
     * @brief Читает один байт данных по указанному адресу
     * 
     * @param address Адрес в памяти (допустимый диапазон: 0–511)
     * @param[out] value В эту переменную будет записан прочитанный байт
     * @return true если чтение успешно, false при ошибке (некорректный адрес)
     */
    bool readByte(uint16_t address, uint8_t& value);

    /**
     * @brief Записывает буфер данных в память
     * 
     * Автоматически разбивает запись на страницы (по 16 байт).
     * Это повышает производительность и гарантирует корректность.
     * 
     * @param address Начальный адрес записи (допустимый диапазон: 0–511)
     * @param data Указатель на буфер с данными для записи
     * @param length Количество байт для записи
     * @return true если вся запись успешна, false при ошибке
     */
    bool writeBuffer(uint16_t address, const uint8_t* data, uint16_t length);
    /**
     * @brief Читает буфер данных из памяти
     * 
     * Выполняет непрерывное чтение без разбиения на страницы
     * 
     * @param address Начальный адрес чтения (допустимый диапазон: 0–511)
     * @param[out] data Указатель на буфер для сохранения прочитанных данных
     * @param length Количество байт для чтения
     * @return true если чтение успешно, false при ошибке
     */
    bool readBuffer(uint16_t address, uint8_t* data, uint16_t length);

    /**
     * @brief Записывает отдельный бит в байте по указанному адресу
     * 
     * Выполняет операцию "чтение-модификация-запись":
     * 1. Читает текущий байт из памяти
     * 2. Изменяет указанный бит (0–7)
     * 3. Записывает изменённый байт обратно
     * 
     * @param address Адрес байта в памяти (допустимый диапазон: 0–511)
     * @param bit Номер бита для изменения (допустимый диапазон: 0–7)
     * @param value Новое значение бита (true = 1, false = 0)
     * @return true если операция успешна, false при ошибке
     */
    bool writeBit(uint16_t address, uint8_t bit, bool value);

    /**
     * @brief Читает отдельный бит из байта по указанному адресу
     * 
     * @param address Адрес байта в памяти (допустимый диапазон: 0–511)
     * @param bit Номер бита для чтения (допустимый диапазон: 0–7)
     * @param[out] value В эту переменную записывается значение бита (true = 1, false = 0)
     * @return true если операция успешна, false при ошибке
     */
    bool readBit(uint16_t address, uint8_t bit, bool& value);

private:
    /**
     * @brief Команды протокола микросхемы 25LC040A
     * 
     * Каждая команда представляет собой один байт, отправляемый в микросхему
     * в начале транзакции.
     */
    enum Command : uint8_t {
        READ = 0x03,  ///< Команда чтения данных
        WRITE = 0x02, ///< Команда записи данных
        WREN = 0x06, ///< Команда разрешения записи
        RDSR = 0x05 ///< Команда чтения статусного регистра
    };

    /// @brief Бит "Write In Progress" (WIP) в статусном регистре
    /// @note Бит = 1 — микросхема записывает данные.
    ///       Бит = 0 — микросхема готова к новой команде.
    static constexpr uint8_t STATUS_WIP = 0x01;
    /**
     * @brief Бит адреса A8, встраиваемый в opcode SPI-команды
     *
     * Микросхема использует 9-битную адресацию,
     * формат передачи по SPI проходит в 2 этапа:
     * - старший бит совместно с командой,
     * - младшие 8 бит
     */
    static constexpr uint8_t OPCODE_ADDR_BIT = 0x08;

    /**
     * @brief Формирует SPI opcode с учётом старшего бита адреса A8
     * 
     * Если старший бит адреса = 1, то он передается совместно с командой
     * 
     * @param cmd Базовая команда SPI (READ или WRITE)
     * @param address Абсолютный адрес в памяти EEPROM
     *
     * @return Итоговый opcode, содержащий базовую команду
     *         и старший бит адреса A8
     */
    uint8_t makeOpcode(Command cmd, uint16_t address);

    /**
     * @brief Отправляет команду разрешения записи (WREN)
     * 
     * Активирует внутренний флаг разрешения записи в микросхеме.
     * Без этой команды любая операция записи будет проигнорирована.
     * 
     * @warning Должна вызываться ПЕРЕД каждой операцией записи.
     */
    void writeEnable();
    /**
     * @brief Читает статусный регистр микросхемы
     * 
     * Статусный регистр содержит информацию о состоянии микросхемы:
     * - Бит = 0 (WIP): Write In Progress — микросхема занята записью
     * - Бит = 1 (WEL): Write Enable Latch — разрешена запись
     * 
     * @return Значение статусного регистра
     */
    uint8_t readStatus();
    
    /**
     * @brief Ждет завершения операции записи
     * 
     * Считывает статусный регистр до тех пор, пока бит WIP не станет равен 0
     * или не истечёт таймаут.
     * 
     * @param timeoutMs Максимальное время ожидания в миллисекундах (по умолчанию 10 мс)
     * @return true если запись завершена успешно, false при таймауте
     * 
     * @note Время выполнения: до 5 мс в нормальном случае (время записи страницы)
     */
    bool waitWriteComplete(uint16_t timeoutMS = 10);
};